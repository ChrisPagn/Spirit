using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;
using Newtonsoft.Json;
using UnityEngine;

/// <summary>
/// Classe responsable de la sauvegarde et du chargement des données de jeu.
/// </summary>
public class LoadAndSaveData : MonoBehaviour
{
    public static LoadAndSaveData instance;

    private string filePath;
    private string encryptionKey = "YourEncryptionKeyHere"; // Remplacez par une clé sécurisée

    /// <summary>
    /// Initialise l'instance singleton et définit le chemin du fichier de sauvegarde.
    /// </summary>
    private void Awake()
    {
        // Vérifie s'il existe déjà une instance de cette classe.
        if (instance != null && instance != this)
        {
            // Si une instance existe déjà, détruit l'objet actuel pour éviter les duplications.
            Destroy(gameObject);
            return;
        }

        // Définit l'instance actuelle comme étant l'instance unique.
        instance = this;

        // Définit le chemin où le fichier de sauvegarde sera stocké.
        filePath = Path.Combine(Application.persistentDataPath, "saveData.json");

        // Si on veut que l'objet persiste entre les scènes, décommentez la ligne suivante :
        // DontDestroyOnLoad(gameObject);
    }

    /// <summary>
    /// Charge les données sauvegardées lorsque le jeu commence.
    /// </summary>
    void Start()
    {
        // Affiche le chemin du fichier de sauvegarde pour le débogage.
        // C:/Users/Chris/AppData/LocalLow/DefaultCompany/Spirit\saveData.json
        Debug.Log("Chemin du fichier de sauvegarde : " + filePath);

        // Charge les données sauvegardées.
        LoadData();
    }

    /// <summary>
    /// Sauvegarde les données actuelles du jeu dans un fichier.
    /// </summary>
    public void SaveData()
    {
        // Crée un objet SaveData contenant les données à sauvegarder.
        var saveData = new SaveData
        {
            CoinsCount = Inventory.instance.coinsCount,
            LevelReached = CurrentSceneManager.instance.levelToUnlock,
            InventoryItems = Inventory.instance.contentItems.ConvertAll(item => item.id)
        };

        try
        {
            // Convertit les données en JSON.
            string json = JsonConvert.SerializeObject(saveData);

            // Chiffre le JSON.
            string encryptedJson = EncryptString(json, encryptionKey);

            // Écrit le JSON chiffré dans le fichier.
            File.WriteAllText(filePath, encryptedJson);
        }
        catch (Exception ex)
        {
            // Affiche une erreur si la sauvegarde échoue.
            Debug.LogError($"Erreur lors de la sauvegarde des données : {ex.Message}");
        }
    }

    /// <summary>
    /// Charge les données sauvegardées à partir du fichier.
    /// </summary>
    private void LoadData()
    {
        // Vérifie si le fichier de sauvegarde existe.
        if (File.Exists(filePath))
        {
            try
            {
                // Lit le contenu chiffré du fichier.
                string encryptedJson = File.ReadAllText(filePath);

                // Déchiffre le contenu.
                string json = DecryptString(encryptedJson, encryptionKey);

                // Désérialise le JSON en un objet SaveData.
                SaveData saveData = JsonConvert.DeserializeObject<SaveData>(json);

                // Si les données sont valides, met à jour les composants du jeu.
                if (saveData != null)
                {
                    Inventory.instance.coinsCount = saveData.CoinsCount;
                    Inventory.instance.UpdateTextUI();

                    // Ajoute les éléments d'inventaire sauvegardés.
                    foreach (int id in saveData.InventoryItems)
                    {
                        Item currentItem = ItemsDataBase.instance.allItems.FirstOrDefault(x => x.id == id);
                        if (currentItem != null)
                        {
                            Inventory.instance.contentItems.Add(currentItem);
                        }
                    }

                    Inventory.instance.UpdateInventoryUI();
                    CurrentSceneManager.instance.levelToUnlock = saveData.LevelReached;
                }
                else
                {
                    // Affiche un avertissement si les données sont corrompues.
                    Debug.LogWarning("Les données sauvegardées sont corrompues ou invalides.");
                }
            }
            catch (Exception ex)
            {
                // Affiche une erreur si le chargement échoue.
                Debug.LogError($"Erreur lors du chargement des données : {ex.Message}");
            }
        }
    }

    /// <summary>
    /// Chiffre une chaîne de texte en utilisant une clé de chiffrement.
    /// </summary>
    /// <param name="plainText">Texte à chiffrer.</param>
    /// <param name="key">Clé de chiffrement.</param>
    /// <returns>Texte chiffré.</returns>
    private string EncryptString(string plainText, string key)
    {
        using (Aes aes = Aes.Create())
        {
            // Utilise un sel pour générer une clé sécurisée.
            byte[] salt = Encoding.UTF8.GetBytes("SaltValue1234");
            aes.Key = new Rfc2898DeriveBytes(key, salt, 10000).GetBytes(32);

            // Génère un vecteur d'initialisation (IV) aléatoire.
            aes.GenerateIV();

            using (MemoryStream memoryStream = new MemoryStream())
            {
                // Écrit l'IV au début du flux.
                memoryStream.Write(aes.IV, 0, aes.IV.Length);

                // Chiffre le texte et l'écrit dans le flux.
                using (CryptoStream cryptoStream = new CryptoStream(memoryStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                using (StreamWriter streamWriter = new StreamWriter(cryptoStream))
                {
                    streamWriter.Write(plainText);
                }

                // Retourne le texte chiffré sous forme de chaîne Base64.
                return Convert.ToBase64String(memoryStream.ToArray());
            }
        }
    }

    /// <summary>
    /// Déchiffre une chaîne de texte en utilisant une clé de déchiffrement.
    /// </summary>
    /// <param name="cipherText">Texte chiffré.</param>
    /// <param name="key">Clé de déchiffrement.</param>
    /// <returns>Texte déchiffré.</returns>
    private string DecryptString(string cipherText, string key)
    {
        try
        {
            // Convertit le texte chiffré de Base64 en tableau d'octets.
            byte[] fullCipher = Convert.FromBase64String(cipherText);

            using (Aes aes = Aes.Create())
            {
                byte[] salt = Encoding.UTF8.GetBytes("SaltValue1234");
                aes.Key = new Rfc2898DeriveBytes(key, salt, 10000).GetBytes(32);

                // Extrait l'IV et le texte chiffré du tableau d'octets.
                byte[] iv = new byte[aes.BlockSize / 8];
                byte[] cipher = new byte[fullCipher.Length - iv.Length];

                Array.Copy(fullCipher, iv, iv.Length);
                Array.Copy(fullCipher, iv.Length, cipher, 0, cipher.Length);

                aes.IV = iv;

                // Déchiffre le texte et le lit dans un flux.
                using (MemoryStream memoryStream = new MemoryStream(cipher))
                using (CryptoStream cryptoStream = new CryptoStream(memoryStream, aes.CreateDecryptor(), CryptoStreamMode.Read))
                using (StreamReader streamReader = new StreamReader(cryptoStream))
                {
                    return streamReader.ReadToEnd();
                }
            }
        }
        catch (Exception ex)
        {
            // Affiche une erreur si le déchiffrement échoue.
            Debug.LogError($"Erreur de déchiffrement : {ex.Message}");
            return null;
        }
    }
}


//*********************
//Aide mémoire
//*********************

// PlayerPrefs sauvegarde les données dans un fichier de registre sur Windows ou un fichier .plist sur macOS
// Ces fichiers sont situés dans un répertoire spécifique à l'application sur le disque de l'utilisateur

//        Fonctionnement de PlayerPrefs:
//        Stockage Local : PlayerPrefs stocke les données en local sur le disque de l'utilisateur.
//                          Sur Windows, les données sont stockées dans le registre,
//                              cmd :Windows + r ==>> taper " regedit "
//                          tandis que sur macOS, elles sont stockées dans un fichier .plist.

//        Persistance: Les données sauvegardées avec PlayerPrefs persistent entre les sessions de jeu,
//                      ce qui signifie qu'elles ne sont pas perdues lorsque le jeu est fermé.

//        Types de Données: PlayerPrefs peut stocker des types de données simples comme des entiers,
//                          des flottants et des chaînes de caractères.

//        Limites : PlayerPrefs n'est pas conçu pour stocker de grandes quantités de données ou des types de données complexes.
//                  Pour des besoins plus avancés, il est recommandé d'utiliser des solutions de sérialisation ou des bases de données.


//**************************************************************************************************
//En cours de réflexion ==>> Solution a prévoir pour optimiser les sauvegardes des données en local
//**************************************************************************************************

// 1. un fichier JSON crypté. Utiliser des bibliothèques comme Newtonsoft.Json pour la gestion JSON et System.Security.Cryptography
// pour le cryptage en C#.

// 2. SQLite : Une base de données légère qui peut être intégrée directement dans votre application. Elle est idéale pour des
// données relationnelles et offre des fonctionnalités de sécurité comme le cryptage.
